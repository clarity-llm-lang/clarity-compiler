module TodoCli

// Todo CLI — persistent command-line todo list.
//
// Storage format (one line per todo):
//   id|done|text
// Example:
//   1|false|Buy milk
//   2|true|Write documentation
//
// Data model: Map<String, String> where key = id as string,
//             value = "done_flag|text" ("true|Buy milk")
//
// Commands (from get_args()):
//   add <text>    — add a new todo
//   list          — print all todos
//   done <id>     — mark todo as complete
//   delete <id>   — remove a todo
//   help          — show usage

// --- Serialization helpers ---

// Extract the "done" flag from a stored value "done|text"
function todo_done(value: String) -> Bool {
  let sep = index_of(value, "|");
  match sep == 0 - 1 {
    True -> False,
    False -> string_eq(substring(value, 0, sep), "true")
  }
}

// Extract the text from a stored value "done|text"
function todo_text(value: String) -> String {
  let sep = index_of(value, "|");
  match sep == 0 - 1 {
    True -> value,
    False -> substring(value, sep + 1, string_length(value))
  }
}

// Pack a todo into the storage format "done|text"
function todo_pack(done: Bool, text: String) -> String {
  match done {
    True -> "true|" ++ text,
    False -> "false|" ++ text
  }
}

// --- Map helper: find the maximum integer key ---
function max_key(keys: List<String>, current_max: Int64) -> Int64 {
  match is_empty(keys) {
    True -> current_max,
    False -> {
      let k = head(keys);
      let n = match string_to_int(k) {
        None -> 0,
        Some(v) -> v
      };
      let new_max = match n > current_max {
        True -> n,
        False -> current_max
      };
      max_key(tail(keys), new_max)
    }
  }
}

// Compute the next ID (max existing ID + 1)
function next_id(todos: Map<String, String>) -> Int64 {
  let keys = map_keys(todos);
  max_key(keys, 0) + 1
}

// --- Parse storage file ---

// Parse one line "id|done|text" into the map (adds entry for the id)
function parse_line(line: String, todos: Map<String, String>) -> Map<String, String> {
  let trimmed = trim(line);
  match string_length(trimmed) == 0 {
    True -> todos,
    False -> {
      let first_sep = index_of(trimmed, "|");
      match first_sep == 0 - 1 {
        True -> todos,
        False -> {
          let id_str = substring(trimmed, 0, first_sep);
          let rest = substring(trimmed, first_sep + 1, string_length(trimmed));
          // rest is "done|text" — already in storage format
          map_set(todos, id_str, rest)
        }
      }
    }
  }
}

// Parse file content into a map of todos
function parse_todos(content: String, todos: Map<String, String>) -> Map<String, String> {
  match string_length(content) == 0 {
    True -> todos,
    False -> {
      let lines = split(content, "\n");
      parse_lines(lines, todos)
    }
  }
}

function parse_lines(lines: List<String>, todos: Map<String, String>) -> Map<String, String> {
  match is_empty(lines) {
    True -> todos,
    False -> {
      let updated = parse_line(head(lines), todos);
      parse_lines(tail(lines), updated)
    }
  }
}

// Serialize the map back to file content (one line per todo)
function serialize_todos(todos: Map<String, String>) -> String {
  let keys = map_keys(todos);
  serialize_keys(keys, todos, "")
}

function serialize_keys(keys: List<String>, todos: Map<String, String>, acc: String) -> String {
  match is_empty(keys) {
    True -> acc,
    False -> {
      let k = head(keys);
      let line = match map_get(todos, k) {
        None -> "",
        Some(v) -> k ++ "|" ++ v ++ "\n"
      };
      serialize_keys(tail(keys), todos, acc ++ line)
    }
  }
}

// --- Command implementations ---

// Add a new todo
function add_todo(todos: Map<String, String>, text: String) -> Map<String, String> {
  let id = next_id(todos);
  let id_str = int_to_string(id);
  map_set(todos, id_str, todo_pack(False, text))
}

// Mark a todo as done (returns unchanged map if id not found)
function mark_done(todos: Map<String, String>, id_str: String) -> Map<String, String> {
  match map_get(todos, id_str) {
    None -> todos,
    Some(v) -> {
      let text = todo_text(v);
      map_set(todos, id_str, todo_pack(True, text))
    }
  }
}

// Delete a todo
function delete_todo(todos: Map<String, String>, id_str: String) -> Map<String, String> {
  map_remove(todos, id_str)
}

// --- Display ---

effect[Log] function print_todo(id_str: String, value: String) -> Unit {
  let done_flag = match todo_done(value) {
    True -> "[x]",
    False -> "[ ]"
  };
  let text = todo_text(value);
  print_string(id_str ++ ". " ++ done_flag ++ " " ++ text)
}

effect[Log] function list_todos(todos: Map<String, String>) -> Unit {
  let keys = map_keys(todos);
  match is_empty(keys) {
    True -> print_string("No todos yet. Use 'add <text>' to create one."),
    False -> print_todos_by_keys(keys, todos)
  }
}

effect[Log] function print_todos_by_keys(keys: List<String>, todos: Map<String, String>) -> Unit {
  match is_empty(keys) {
    True -> print_string(""),
    False -> {
      let k = head(keys);
      match map_get(todos, k) {
        None -> print_todos_by_keys(tail(keys), todos),
        Some(v) -> {
          print_todo(k, v);
          print_todos_by_keys(tail(keys), todos)
        }
      }
    }
  }
}

effect[Log] function show_help() -> Unit {
  print_string("Usage: todo <command> [args]");
  print_string("Commands:");
  print_string("  add <text>   Add a new todo");
  print_string("  list         Show all todos");
  print_string("  done <id>    Mark todo as done");
  print_string("  delete <id>  Delete a todo");
  print_string("  help         Show this help")
}

// --- Argument parsing ---

// Get the command from args (first arg)
function get_command(args: List<String>) -> String {
  match is_empty(args) {
    True -> "help",
    False -> head(args)
  }
}

// Get the text argument (join remaining args with spaces)
function get_text_arg(args: List<String>) -> String {
  match is_empty(args) {
    True -> "",
    False -> join_args(tail(args), "")
  }
}

function join_args(args: List<String>, acc: String) -> String {
  match is_empty(args) {
    True -> acc,
    False -> {
      let sep = match string_length(acc) == 0 { True -> "", False -> " " };
      join_args(tail(args), acc ++ sep ++ head(args))
    }
  }
}

// Get the ID argument (second arg as string)
function get_id_arg(args: List<String>) -> String {
  match is_empty(args) {
    True -> "",
    False -> match is_empty(tail(args)) {
      True -> "",
      False -> head(tail(args))
    }
  }
}

// --- Main ---

effect[FileSystem, Log] function main() -> Unit {
  let file = "todos.txt";
  let content = read_file(file);
  let empty: Map<String, String> = map_new();
  let todos = parse_todos(content, empty);
  let args = get_args();
  let cmd = get_command(args);
  execute_command(cmd, args, todos, file)
}

effect[FileSystem, Log] function execute_command(
  cmd: String,
  args: List<String>,
  todos: Map<String, String>,
  file: String
) -> Unit {
  match string_eq(cmd, "add") {
    True -> {
      let text = get_text_arg(args);
      match string_length(text) == 0 {
        True -> print_string("Error: 'add' requires a todo text"),
        False -> {
          let updated = add_todo(todos, text);
          let id = next_id(todos);
          write_file(file, serialize_todos(updated));
          print_string("Added todo #" ++ int_to_string(id) ++ ": " ++ text)
        }
      }
    },
    False -> match string_eq(cmd, "list") {
      True -> list_todos(todos),
      False -> match string_eq(cmd, "done") {
        True -> {
          let id_str = get_id_arg(args);
          match string_length(id_str) == 0 {
            True -> print_string("Error: 'done' requires an id"),
            False -> {
              let updated = mark_done(todos, id_str);
              write_file(file, serialize_todos(updated));
              print_string("Marked #" ++ id_str ++ " as done")
            }
          }
        },
        False -> match string_eq(cmd, "delete") {
          True -> {
            let id_str = get_id_arg(args);
            match string_length(id_str) == 0 {
              True -> print_string("Error: 'delete' requires an id"),
              False -> {
                let updated = delete_todo(todos, id_str);
                write_file(file, serialize_todos(updated));
                print_string("Deleted todo #" ++ id_str)
              }
            }
          },
          False -> show_help()
        }
      }
    }
  }
}

// --- Tests ---

effect[Test] function test_todo_pack_undone() -> Unit {
  assert_eq_string(todo_pack(False, "Buy milk"), "false|Buy milk")
}

effect[Test] function test_todo_pack_done() -> Unit {
  assert_eq_string(todo_pack(True, "Write docs"), "true|Write docs")
}

effect[Test] function test_todo_done_flag_false() -> Unit {
  assert_false(todo_done("false|Buy milk"))
}

effect[Test] function test_todo_done_flag_true() -> Unit {
  assert_true(todo_done("true|Write docs"))
}

effect[Test] function test_todo_text_extraction() -> Unit {
  assert_eq_string(todo_text("false|Buy milk"), "Buy milk")
}

effect[Test] function test_todo_text_with_pipe() -> Unit {
  assert_eq_string(todo_text("false|Buy milk|today"), "Buy milk|today")
}

effect[Test] function test_add_todo_increments_id() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "First");
  let m3 = add_todo(m2, "Second");
  assert_eq(map_size(m3), 2)
}

effect[Test] function test_add_todo_assigns_id_1() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "First");
  assert_true(map_has(m2, "1"))
}

effect[Test] function test_add_todo_assigns_sequential_ids() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "A");
  let m3 = add_todo(m2, "B");
  let m4 = add_todo(m3, "C");
  assert_true(map_has(m4, "3"))
}

effect[Test] function test_mark_done() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "Buy milk");
  let m3 = mark_done(m2, "1");
  let v = match map_get(m3, "1") { None -> "false|", Some(v) -> v };
  assert_true(todo_done(v))
}

effect[Test] function test_mark_done_preserves_text() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "Buy milk");
  let m3 = mark_done(m2, "1");
  let v = match map_get(m3, "1") { None -> "false|", Some(v) -> v };
  assert_eq_string(todo_text(v), "Buy milk")
}

effect[Test] function test_delete_todo() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "Buy milk");
  let m3 = add_todo(m2, "Write docs");
  let m4 = delete_todo(m3, "1");
  assert_eq(map_size(m4), 1);
  assert_false(map_has(m4, "1"))
}

effect[Test] function test_delete_nonexistent_ok() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "Keep me");
  let m3 = delete_todo(m2, "99");
  assert_eq(map_size(m3), 1)
}

effect[Test] function test_parse_todos_from_content() -> Unit {
  let content = "1|false|Buy milk\n2|true|Write docs\n";
  let empty: Map<String, String> = map_new();
  let todos = parse_todos(content, empty);
  assert_eq(map_size(todos), 2)
}

effect[Test] function test_parse_todos_preserves_done_flag() -> Unit {
  let content = "1|true|Done task\n";
  let empty: Map<String, String> = map_new();
  let todos = parse_todos(content, empty);
  let v = match map_get(todos, "1") { None -> "false|", Some(v) -> v };
  assert_true(todo_done(v))
}

effect[Test] function test_serialize_round_trip() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "Test task");
  let serialized = serialize_todos(m2);
  let empty2: Map<String, String> = map_new();
  let parsed = parse_todos(serialized, empty2);
  assert_eq(map_size(parsed), 1)
}

effect[Test] function test_join_args() -> Unit {
  let args = ["hello", "world", "!"];
  assert_eq_string(join_args(args, ""), "hello world !")
}

effect[Test] function test_get_command_empty() -> Unit {
  let args: List<String> = [];
  assert_eq_string(get_command(args), "help")
}

effect[Test] function test_get_command_first_arg() -> Unit {
  let args = ["add", "some text"];
  assert_eq_string(get_command(args), "add")
}

effect[Test] function test_next_id_empty_map() -> Unit {
  let m: Map<String, String> = map_new();
  assert_eq(next_id(m), 1)
}

effect[Test] function test_next_id_after_adds() -> Unit {
  let m: Map<String, String> = map_new();
  let m2 = add_todo(m, "A");
  let m3 = add_todo(m2, "B");
  assert_eq(next_id(m3), 3)
}

# Clarity Language Grammar (PEG notation)
# A programming language optimized for LLM code generation

# === Top Level ===
Module          <- 'module' Identifier ModuleBody
ModuleBody      <- (ImportDecl / ExportDecl / TypeDecl / FunctionDecl / ConstDecl)*

# === Declarations ===
ImportDecl      <- 'import' '{' Identifier (',' Identifier)* '}' 'from' StringLiteral
ExportDecl      <- 'export' (TypeDecl / FunctionDecl / ConstDecl)
TypeDecl        <- 'type' Identifier TypeParams? '=' TypeExpr
FunctionDecl    <- EffectAnnotation? 'function' Identifier TypeParams? '(' ParamList ')' '->' TypeRef Block
TypeParams      <- '<' Identifier (',' Identifier)* '>'
ConstDecl       <- 'const' Identifier ':' TypeRef '=' Expression ';'

EffectAnnotation <- 'effect' '[' EffectList ']'
EffectList       <- Identifier (',' Identifier)*

ParamList       <- (Param (',' Param)*)?
Param           <- Identifier ':' TypeRef

# === Types ===
TypeRef         <- FunctionType / Identifier ('<' TypeArgList '>')?
FunctionType    <- '(' (TypeRef (',' TypeRef)*)? ')' '->' TypeRef
TypeArgList     <- TypeRef (',' TypeRef)*

TypeExpr        <- RecordType / UnionType / TypeRef
RecordType      <- '{' FieldList '}'
FieldList       <- Field (',' Field)* ','?
Field           <- Identifier ':' TypeRef

UnionType       <- '|' VariantDef ('|' VariantDef)*
VariantDef      <- Identifier ('(' FieldList ')')?

# === Expressions ===
Expression      <- MatchExpr / LetExpr / AssignmentExpr / BinaryExpr
LetExpr         <- 'let' 'mut'? Pattern '=' Expression
AssignmentExpr  <- Identifier '=' Expression
MatchExpr       <- 'match' Expression '{' MatchArm+ '}'
MatchArm        <- Pattern ('if' Expression)? '->' Expression ','?

BinaryExpr      <- UnaryExpr (BinaryOp UnaryExpr)*
UnaryExpr       <- ('!' / '-') UnaryExpr / CallExpr
CallExpr        <- PrimaryExpr ('(' ArgList ')')* ('.' Identifier ('(' ArgList ')')?)*
PrimaryExpr     <- Literal / Identifier / '(' Expression ')' / Block

# Operator precedence (low to high):
#   1: or
#   2: and
#   3: == !=
#   4: < > <= >=
#   5: + - ++
#   6: * / %
#   7: unary - !
BinaryOp        <- 'or' / 'and' / '==' / '!=' / '<=' / '>=' / '<' / '>'
                 / '+' / '-' / '++' / '*' / '/' / '%'

ArgList         <- (Arg (',' Arg)*)?
Arg             <- (Identifier ':')? Expression

Block           <- '{' Statement* Expression? '}'
Statement       <- LetExpr ';' / AssignmentExpr ';' / Expression ';'

# === Patterns ===
Pattern         <- WildcardPat / RangePat / LiteralPat / ConstructorPat / BindingPat
WildcardPat     <- '_'
RangePat        <- IntLiteral '..' IntLiteral
LiteralPat      <- IntLiteral / FloatLiteral / StringLiteral / 'True' / 'False'
ConstructorPat  <- Identifier ('(' PatternFieldList ')')?
PatternFieldList <- PatternField (',' PatternField)*
PatternField    <- (Identifier ':')? Pattern
BindingPat      <- Identifier

# === Literals ===
Literal         <- IntLiteral / FloatLiteral / StringLiteral / BoolLiteral / ListLiteral
IntLiteral      <- [0-9]+
FloatLiteral    <- [0-9]+ '.' [0-9]+
StringLiteral   <- '"""' [^]* '"""' / '"' [^"]* '"'
BoolLiteral     <- 'True' / 'False'
ListLiteral     <- '[' (Expression (',' Expression)*)? ']'

# === Tokens ===
Identifier      <- [a-zA-Z_][a-zA-Z0-9_]*

# === Comments ===
LineComment     <- '//' [^\n]*

# === Built-in Generic Types (not part of grammar, resolved in the checker) ===
# List<T>         — ordered collection
# Option<T>       — Some(value: T) | None
# Result<T, E>    — Ok(value: T) | Err(error: E)
# Map<K, V>       — immutable key-value mapping (K: String or Int64, V: any type)
#
# === Type Aliases ===
# type Name = ExistingType    (transparent — alias is interchangeable with underlying type)
#
# === Known Effects ===
# DB, Network, Time, Random, Log, FileSystem, Test, Model, Secret, MCP, A2A
#
# === Built-in Functions (not part of grammar, but available in the environment) ===
# I/O (FileSystem effect): read_line, read_all_stdin, read_file, write_file, get_args, exit
# Logging (Log effect): print_string, print_int, print_float, log_info, log_warn
# Strings: string_concat, string_eq, string_length, substring, char_at, char_code, char_from_code, contains, index_of, trim, split
# Conversions: int_to_float, float_to_int, int_to_string, float_to_string, string_to_int, string_to_float
# Math: abs_int, min_int, max_int, sqrt, pow, floor, ceil
# Lists: length, head, tail, append, concat, reverse, is_empty, nth
# Maps: map_new, map_get, map_set, map_remove, map_has, map_size, map_keys, map_values
# JSON: json_parse, json_stringify, json_get
# Bytes: bytes_new, bytes_length, bytes_get, bytes_set, bytes_slice, bytes_concat, bytes_from_string, bytes_to_string
# Timestamps (Time effect): now, timestamp_to_string, timestamp_to_int, timestamp_from_int, timestamp_add, timestamp_diff
# Tests (Test effect): assert_eq, assert_eq_float, assert_eq_string, assert_true, assert_false
# Model (Model effect): call_model, call_model_system, list_models
# Secret (Secret effect): get_secret
# MCP (MCP effect): mcp_connect, mcp_list_tools, mcp_call_tool, mcp_disconnect
# A2A (A2A effect): a2a_discover, a2a_submit, a2a_poll, a2a_cancel
# Policy (no effect): policy_is_url_allowed, policy_is_effect_allowed

# Clarity Language Grammar (PEG notation)
# A programming language optimized for LLM code generation

# === Top Level ===
Module          <- 'module' Identifier ModuleBody
ModuleBody      <- (TypeDecl / FunctionDecl / ConstDecl)*

# === Declarations ===
TypeDecl        <- 'type' Identifier TypeParams? '=' TypeExpr
FunctionDecl    <- EffectAnnotation? 'function' Identifier TypeParams? '(' ParamList ')' '->' TypeRef Block
TypeParams      <- '<' Identifier (',' Identifier)* '>'
ConstDecl       <- 'const' Identifier ':' TypeRef '=' Expression ';'

EffectAnnotation <- 'effect' '[' EffectList ']'
EffectList       <- Identifier (',' Identifier)*

ParamList       <- (Param (',' Param)*)?
Param           <- Identifier ':' TypeRef

# === Types ===
TypeRef         <- FunctionType / Identifier ('<' TypeArgList '>')?
FunctionType    <- '(' (TypeRef (',' TypeRef)*)? ')' '->' TypeRef
TypeArgList     <- TypeRef (',' TypeRef)*

TypeExpr        <- RecordType / UnionType / TypeRef
RecordType      <- '{' FieldList '}'
FieldList       <- Field (',' Field)* ','?
Field           <- Identifier ':' TypeRef

UnionType       <- '|' VariantDef ('|' VariantDef)*
VariantDef      <- Identifier ('(' FieldList ')')?

# === Expressions ===
Expression      <- MatchExpr / LetExpr / AssignmentExpr / BinaryExpr
LetExpr         <- 'let' 'mut'? Pattern '=' Expression
AssignmentExpr  <- Identifier '=' Expression
MatchExpr       <- 'match' Expression '{' MatchArm+ '}'
MatchArm        <- Pattern '->' Expression ','?

BinaryExpr      <- UnaryExpr (BinaryOp UnaryExpr)*
UnaryExpr       <- ('!' / '-') UnaryExpr / CallExpr
CallExpr        <- PrimaryExpr ('(' ArgList ')')* ('.' Identifier ('(' ArgList ')')?)*
PrimaryExpr     <- Literal / Identifier / '(' Expression ')' / Block

# Operator precedence (low to high):
#   1: or
#   2: and
#   3: == !=
#   4: < > <= >=
#   5: + - ++
#   6: * / %
#   7: unary - !
BinaryOp        <- 'or' / 'and' / '==' / '!=' / '<=' / '>=' / '<' / '>'
                 / '+' / '-' / '++' / '*' / '/' / '%'

ArgList         <- (Arg (',' Arg)*)?
Arg             <- (Identifier ':')? Expression

Block           <- '{' Statement* Expression? '}'
Statement       <- LetExpr ';' / AssignmentExpr ';' / Expression ';'

# === Patterns ===
Pattern         <- WildcardPat / LiteralPat / ConstructorPat / BindingPat
WildcardPat     <- '_'
LiteralPat      <- IntLiteral / FloatLiteral / StringLiteral / 'True' / 'False'
ConstructorPat  <- Identifier ('(' PatternFieldList ')')?
PatternFieldList <- PatternField (',' PatternField)*
PatternField    <- (Identifier ':')? Pattern
BindingPat      <- Identifier

# === Literals ===
Literal         <- IntLiteral / FloatLiteral / StringLiteral / BoolLiteral / ListLiteral
IntLiteral      <- [0-9]+
FloatLiteral    <- [0-9]+ '.' [0-9]+
StringLiteral   <- '"' [^"]* '"'
BoolLiteral     <- 'True' / 'False'
ListLiteral     <- '[' (Expression (',' Expression)*)? ']'

# === Tokens ===
Identifier      <- [a-zA-Z_][a-zA-Z0-9_]*

# === Comments ===
LineComment     <- '//' [^\n]*

# === Built-in Generic Types (not part of grammar, resolved in the checker) ===
# List<T>         — ordered collection
# Option<T>       — Some(value: T) | None
# Result<T, E>    — Ok(value: T) | Err(error: E)
#
# === Type Aliases ===
# type Name = ExistingType    (transparent — alias is interchangeable with underlying type)
#
# === Built-in Functions (not part of grammar, but available in the environment) ===
# I/O (FileSystem effect): read_line, read_all_stdin, read_file, write_file, get_args, exit
# Logging (Log effect): print_string, print_int, print_float, log_info, log_warn
# Strings: string_concat, string_eq, string_length, substring, char_at, contains, index_of, trim, split
# Conversions: int_to_float, float_to_int, int_to_string, float_to_string, string_to_int, string_to_float
# Math: abs_int, min_int, max_int, sqrt, pow, floor, ceil
# Lists: length, head, tail, append, concat, reverse, is_empty, nth
# Tests (Test effect): assert_eq, assert_eq_float, assert_eq_string, assert_true, assert_false
